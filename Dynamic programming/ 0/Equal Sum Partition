##Using recursion
class Solution {
    //simple recursion approach where you can take or not take the val to add in target , where target= sum/2
    public boolean canPartition(int[] nums) {
        int sum=0;
        for(int i=0 ; i< nums.length ; i++){
            sum += nums[i];
        }
        if(sum % 2 != 0){
            return false;
        }
        return findPartition(nums , 0 , sum/2);
    }

    public boolean findPartition(int[] nums , int i , int target){
        if(target == 0){
            return true;
        }
        if(i == nums.length || target < 0)
            return false;
       return findPartition(nums , i+1 , target-nums[i])|| findPartition(nums , i+1 , target);
      }
}




###using memoization 

class Solution {
    //simple recursion approach where you can take or not take the val to add in target , where target= sum/2
    public boolean canPartition(int[] nums) {
        int sum=0;
        int n = nums.length;
          //if the sum is divisible by means array can be divided in equal parts
        for(int i=0 ; i< nums.length ; i++){
            sum += nums[i];
        }
        if(sum % 2 != 0){
            return false;
        }else{
         //Use **boolean[][]** when you're fine with all cells being false initially.

        //Use **Boolean[][]** when you need to distinguish between "not yet calculated" and "false result", especially in recursive memoization. 
        Boolean[][] mat = new Boolean[n+1][sum/2+1];
        return findPartition(nums , sum/2, mat ,n-1);
        }
    }

    public boolean findPartition(int[] nums , int target , Boolean[][] mat , int n){
        
        if(target == 0){
            return true;
        }
        //if n becomes less than zero means all the indexes are traversed so return false , or if the target becomes less than zero means target sum couldn't find 
        if(n<0 || target < 0)
            return false;
        //to check if the value at indices mat[n][target] is calculated or not;if calculated we use the ans.
         if(mat[n][target] != null){
            return mat[n][target];
        }

        //we are either taking a value or not taking 
        return mat[n][target] = findPartition(nums , target-nums[n], mat ,  n-1)|| findPartition(nums, target ,mat , n-1);

        
    }
}

